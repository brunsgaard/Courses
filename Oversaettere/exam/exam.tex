\documentclass[11pt,a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[T1]{fontenc}
\usepackage{listings}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{graphicx}

\title{Report for ordinary compiler exam at DIKU - Taskset 4}
\author{Jonas Brunsgaard (msn368}

\begin{document}
\maketitle

\section{Top-Down Parsing for if-then-else}
In this assignment we will work our way forward to determine whether or not
a grammar is LL(1). This can be determined by deriving the Look-ahead sets for
the grammar.

To derive the Look-ahead sets we need to eliminate any left
recursion, left-factorize the grammar, determine nullabilility, first sets
and follow sets.

The procedure used in this assignment are described in
the book section 2.12, With the one exception that we use Look-ahead sets
instead of a parse table to determine if the grammar is LL(1). Look ahead sets
are described in the slides from the parser lecture.

\subsection{Left-factorization of the grammar}
Below is the new grammar after left-factorization.
$$
\begin{array}{lcl}
    S & \rightarrow & \mathrm{if\:}BSS_* \\
    S & \rightarrow & \mathrm{return\:NUM;} \\
    S_* & \rightarrow & \varepsilon \\
    S_* & \rightarrow & \mathrm{else}\:S \\
    B & \rightarrow & \mathrm{(\,NUM\,)} \\
\end{array}
$$

\subsection{Nullablility and First sets}

First we determine if terminals and nonterminals are \emph{nullable}.

\begin{center}
\begin{tabular}{c||c|c|c}
Right-hand side & Init & First Iter & Sec Iter\tabularnewline
\hline 
\hline 
$\mathrm{if\:}BSS*$ & \emph{false} & \emph{false} & \emph{false}\tabularnewline
\hline 
$\mathrm{return\:NUM;}$ & \emph{false} & \emph{false} & \emph{false}\tabularnewline
\hline 
$\varepsilon$ & \emph{false} & \emph{true} & \emph{true}\tabularnewline
\hline 
$\mathrm{else}\:S$ & \emph{false} & \emph{false} & \emph{false}\tabularnewline
\hline 
$\mathrm{(\,NUM\,)}$ & \emph{false} & \emph{false} & \emph{false}\tabularnewline
\hline 
Nonterminal & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \tabularnewline
\hline 
$S$ & \emph{false} & \emph{false} & \emph{false}\tabularnewline
\hline 
$S_*$ & \emph{false} & \emph{true} & \emph{true}\tabularnewline
\hline 
$B$ & \emph{false} & \emph{false} & \emph{false}\tabularnewline
\end{tabular}
\end{center}
Then we use fixed point iteration to determine the \emph{FIRST}-sets:
\begin{center}
\begin{tabular}{c||c|c|c}
Right-hand side & Init & First Iter & Sec Iter\tabularnewline
\hline 
\hline 
$\mathrm{if\:}BSS_*$       & $\emptyset$ & \{if\}        & \{if\}        \tabularnewline
\hline                                                                
$\mathrm{return\:NUM;}$ & $\emptyset$ & \{return\}    & \{return\}    \tabularnewline
\hline                                                                
$\varepsilon$           & $\emptyset$ & $\emptyset$   & $\emptyset$   \tabularnewline
\hline                                                                
$\mathrm{else}\:S$      & $\emptyset$ & \{else\}      & \{else\}      \tabularnewline
\hline                                                                
$\mathrm{(\,NUM\,)}$    & $\emptyset$ & \{(\}         & \{(\}         \tabularnewline
\hline 
Nonterminal & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \tabularnewline
\hline 
$S$                     & $\emptyset$ & \{if,return\} & \{if,return\} \tabularnewline
\hline                                                                  
$S_*$                   & $\emptyset$ & \{else\}      & \{else\}      \tabularnewline
\hline                                                                 
$B$                     & $\emptyset$ & \{(\}         & \{(\}         \tabularnewline
\end{tabular}               
\end{center}                

\subsection{Calculate Follow sets for all nonterminals}
By following the procedure found on page 59 in the book, we derive the table
below. To handle the end-of-string condition we add
$$S'\rightarrow S\$$$
to the production

\begin{center}
    \begin{tabular}{ll}
\hline 
Production & Constraints\tabularnewline
\hline 
$S'     \rightarrow S\$$                    & $\{\$\}\subseteq FOLLOW(S)$ \tabularnewline
$S      \rightarrow \mathrm{if\:}BSS_*$     & \begin{minipage}[t]{0.5\columnwidth}
                                                $\{\mathrm{return, if}\}\subseteq FOLLOW(B)$,\\
                                                $FOLLOW(S) \subseteq FOLLOW(S_*)$,\\
                                                $\{\mathrm{else}\} \subseteq FOLLOW(S)$
                                                \end{minipage}
                                                \tabularnewline

$S      \rightarrow \mathrm{return\:NUM;}$  & \tabularnewline
$S_{*}  \rightarrow \varepsilon$            & \tabularnewline
$S_{*}  \rightarrow \mathrm{else}\:S$       & $FOLLOW(S_*) \subseteq FOLLOW(S)$ \tabularnewline
$B      \rightarrow \mathrm{(\:NUM\:)}$     & \tabularnewline
\hline
\end{tabular}
\end{center}

We first use the constraints $ \{\$\} \subseteq FOLLOW(S)$ and constraints
of the form $FIRST(\dots)\subseteq FOLLOW(\dots)$ to get the initial sets.

\begin{eqnarray*}
    FOLLOW(S)       & \subseteq & \{\mathrm{else, \$} \} \\
    FOLLOW(S_*)     & \subseteq & \{\emptyset\} \\
    FOLLOW(B)       & \subseteq & \{\mathrm{if, return}\} \\
\end{eqnarray*}

and then use the constrains on the form $FOLLOW(\dots)\subseteq FOLLOW(\dots)$:

\begin{eqnarray*}
    FOLLOW(S)       & \subseteq & \{\mathrm{else, \$} \} \\
    FOLLOW(S_*)     & \subseteq & \{\mathrm{else, \$} \} \\
    FOLLOW(B)       & \subseteq & \{\mathrm{if, return}\} \\
\end{eqnarray*}

\subsection{Look-aheads sets}

From the lecture slides the look ahead set is defined as

$$la(X\rightarrow\alpha)=
\begin{cases}
    FIRST(\alpha)\cup FOLLOW(X) & \textrm{, if }NULLABLE(\alpha)\\
    FIRST(\alpha)               & \textrm{, otherwise}
\end{cases}$$
Below you see the lookahead sets for our productions.
$$
\begin{array}{lcl}
    LA(S   \rightarrow  \mathrm{if\:}BSS_*)     & = &      \{\mathrm{if}\} \\
    LA(S   \rightarrow  \mathrm{return\:NUM;})  & = &      \{\mathrm{return}\} \\
    LA(S_* \rightarrow  \varepsilon)            & = &      \{\mathrm{else,} \$\} \\
    LA(S_* \rightarrow  \mathrm{else}\:S)       & = &      \{\mathrm{else}\} \\
    LA(B   \rightarrow  \mathrm{(\,NUM\,)})     & = &      \{\mathrm{(}\} \\
\end{array}
$$
From the course slides on parsing we know that if for each nonterminal $X
\in N$ in grammar $G$, all productions of $X$ have disjoint look-ahead sets,
then the grammar $G$ is LL(1). This is not the case in out grammar d to the
production $S_*$, an thus our production is not LL(1)

\subsection{Resolving ambiguity in a recursive-decent parser}



\end{document}
